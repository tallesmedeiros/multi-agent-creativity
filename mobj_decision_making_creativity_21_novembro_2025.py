# -*- coding: utf-8 -*-
"""MOBJ Decision Making Creativity - 21 Novembro 2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zahx0pxvrErc52AT49Co1Jgt2HAKS57d
"""

!pip install numba

"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     FRAMEWORK HÃBRIDO DE DECISÃƒO MULTIAGENTE v5.0 - COMPLETE EDITION          â•‘
â•‘           Performance Otimizada + VisualizaÃ§Ãµes Ricas + Resultados Completos  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Para executar no Google Colab:
1. Copie todo este cÃ³digo para uma cÃ©lula
2. Execute com Shift+Enter
3. Siga as instruÃ§Ãµes interativas
"""

# ========================= INSTALAÃ‡ÃƒO DE DEPENDÃŠNCIAS =========================
import os
import sys
import json
import time
import hashlib
import warnings
import numpy as np
import pandas as pd
import re
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import itertools
from collections import defaultdict, OrderedDict
from datetime import datetime
import random
from functools import lru_cache, partial
from multiprocessing import Pool, cpu_count
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import pickle

# Tenta importar Numba para compilaÃ§Ã£o JIT
try:
    from numba import jit, njit
    NUMBA_AVAILABLE = True
except ImportError:
    NUMBA_AVAILABLE = False
    print("â„¹ï¸ Numba nÃ£o disponÃ­vel - usando implementaÃ§Ã£o Python pura")

# Tenta importar bibliotecas de visualizaÃ§Ã£o
try:
    import matplotlib.pyplot as plt
    import seaborn as sns
    from IPython.display import display, HTML, clear_output
    import plotly.graph_objects as go
    import plotly.express as px
    VISUALIZATION_AVAILABLE = True
except ImportError:
    VISUALIZATION_AVAILABLE = False
    print("âš ï¸ Instalando bibliotecas de visualizaÃ§Ã£o...")
    os.system('pip install -q matplotlib seaborn plotly')
    import matplotlib.pyplot as plt
    import seaborn as sns
    import plotly.graph_objects as go
    import plotly.express as px
    from IPython.display import display, HTML, clear_output
    VISUALIZATION_AVAILABLE = True

# ConfiguraÃ§Ã£o de estilo
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")
warnings.filterwarnings('ignore')

# ========================= CONFIGURAÃ‡Ã•ES GLOBAIS =========================

class Config:
    """ğŸ”§ ConfiguraÃ§Ãµes centralizadas do sistema otimizado"""

    # Modo de operaÃ§Ã£o
    USE_LLM = False
    OPENAI_API_KEY = ""

    # ParÃ¢metros de simulaÃ§Ã£o
    SIMULATION_MODE = "hybrid"
    CACHE_LLM_RESPONSES = True
    MAX_LLM_CALLS = 10

    # Performance
    USE_PARALLEL = True
    MAX_WORKERS = min(4, cpu_count())
    USE_VECTORIZATION = True
    CACHE_SIZE = 1000

    # OtimizaÃ§Ãµes
    USE_NUMBA = NUMBA_AVAILABLE
    BATCH_SIZE = 32
    USE_SIMULATED_ANNEALING = True

    # VisualizaÃ§Ã£o
    SHOW_ANIMATIONS = True
    PLOT_STYLE = "interactive"

    # Debug
    VERBOSE = True
    SHOW_TIMING = True
    PROFILE = False

# ========================= CACHE OTIMIZADO =========================

class OptimizedCache:
    """ğŸ’¾ Sistema de cache otimizado com LRU e persistÃªncia"""

    def __init__(self, max_size=1000):
        self.max_size = max_size
        self.cache = OrderedDict()
        self.hits = 0
        self.misses = 0

    def get(self, key: str) -> Optional[Any]:
        """Busca no cache com LRU"""
        if key in self.cache:
            self.hits += 1
            # Move para o final (mais recente)
            self.cache.move_to_end(key)
            return self.cache[key]
        self.misses += 1
        return None

    def put(self, key: str, value: Any) -> None:
        """Adiciona ao cache com limite de tamanho"""
        if key in self.cache:
            self.cache.move_to_end(key)
        elif len(self.cache) >= self.max_size:
            # Remove o mais antigo
            self.cache.popitem(last=False)
        self.cache[key] = value

    @property
    def hit_rate(self) -> float:
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0.0

# ========================= FUNÃ‡Ã•ES OTIMIZADAS COM NUMBA =========================

if NUMBA_AVAILABLE:
    @njit
    def kendall_tau_numba(r1: np.ndarray, r2: np.ndarray) -> float:
        """Kendall tau compilado com Numba - atÃ© 10x mais rÃ¡pido"""
        n = len(r1)
        if n <= 1:
            return 1.0

        concordant = 0
        discordant = 0

        for i in range(n):
            for j in range(i + 1, n):
                if (r1[i] < r1[j] and r2[i] < r2[j]) or (r1[i] > r1[j] and r2[i] > r2[j]):
                    concordant += 1
                else:
                    discordant += 1

        total = n * (n - 1) / 2
        return (concordant - discordant) / total if total > 0 else 1.0
else:
    def kendall_tau_numba(r1, r2):
        return None  # Fallback serÃ¡ usado

# ========================= ENUMS E TIPOS =========================

class MetricPreference(Enum):
    """ğŸ“Š NÃ­veis de preferÃªncia para mÃ©tricas"""
    MUITO_BAIXA = (0.1, "â–ª", "#FF6B6B")
    BAIXA = (0.3, "â–ªâ–ª", "#FFA07A")
    MEDIA = (0.5, "â–ªâ–ªâ–ª", "#FFD700")
    ALTA = (0.7, "â–ªâ–ªâ–ªâ–ª", "#90EE90")
    MUITO_ALTA = (0.9, "â–ªâ–ªâ–ªâ–ªâ–ª", "#4CAF50")

    @property
    def value(self):
        return self._value_[0]

    @property
    def visual(self):
        return self._value_[1]

    @property
    def color(self):
        return self._value_[2]

class ConsensusMethod(Enum):
    """ğŸ¯ MÃ©todos de consenso disponÃ­veis"""
    BORDA = ("borda", "ğŸ“Š", "Contagem de Borda")
    CONDORCET = ("condorcet", "âš”ï¸", "Vencedor de Condorcet")
    NASH = ("nash", "ğŸ¤", "Nash Bargaining")
    SHAPLEY = ("shapley", "ğŸ’", "Valor de Shapley")
    LLM_MEDIATED = ("llm", "ğŸ§ ", "Mediado por LLM")
    HYBRID = ("hybrid", "ğŸ”€", "HÃ­brido Adaptativo")

class CreativityMetric(Enum):
    """âœ¨ MÃ©tricas de criatividade"""
    FLUENCIA = ("fluÃªncia", "ğŸ’¡", "Quantidade de ideias")
    ORIGINALIDADE = ("originalidade", "ğŸ¨", "Unicidade e novidade")
    FLEXIBILIDADE = ("flexibilidade", "ğŸ”„", "Diversidade de abordagens")
    ELABORACAO = ("elaboraÃ§Ã£o", "ğŸ”¬", "Detalhamento e refinamento")
    ADEQUACAO = ("adequaÃ§Ã£o", "âœ…", "Praticidade e viabilidade")
    IMPACTO = ("impacto", "ğŸ’¥", "Potencial transformador")

    @property
    def value(self):
        return self._value_[0]

    @property
    def icon(self):
        return self._value_[1]

    @property
    def description(self):
        return self._value_[2]

# ========================= SIMULADOR DE LLM OTIMIZADO =========================

class OptimizedLLMSimulator:
    """ğŸ¤– Simulador de LLM otimizado com cache e batch processing"""

    def __init__(self):
        self.cache = OptimizedCache(Config.CACHE_SIZE)
        self.call_count = 0
        self.stats = {"llm_calls": 0, "cache_hits": 0}
        self.patterns = self._compile_patterns()

    def _compile_patterns(self) -> Dict:
        """PrÃ©-compila padrÃµes regex para performance"""
        profiles_keywords = {
            "engenheiro": {
                "positive": ["ferramenta", "precisos", "calibrar", "circuito", "estabilizar"],
                "negative": ["arte", "sons", "decorativo"],
                "boost_metrics": ["adequaÃ§Ã£o", "elaboraÃ§Ã£o"]
            },
            "artista": {
                "positive": ["arte", "criar", "texturas", "mÃ³bile", "sons"],
                "negative": ["ferramenta", "precisos"],
                "boost_metrics": ["originalidade", "flexibilidade"]
            },
            "cientista": {
                "positive": ["precisos", "calibrar", "circuito", "elÃ©trico"],
                "negative": ["improvisada", "decorativo"],
                "boost_metrics": ["elaboraÃ§Ã£o", "impacto"]
            }
        }

        compiled = {}
        for profile, keywords in profiles_keywords.items():
            compiled[profile] = {
                "positive": re.compile('|'.join(keywords["positive"]), re.IGNORECASE),
                "negative": re.compile('|'.join(keywords["negative"]), re.IGNORECASE),
                "boost_metrics": keywords["boost_metrics"]
            }
        return compiled

    def evaluate_solution(self, solution: str, agent_profile: str) -> Dict:
        """Avalia soluÃ§Ã£o com cache"""
        cache_key = hashlib.md5(f"{solution}_{agent_profile}".encode()).hexdigest()
        cached = self.cache.get(cache_key)

        if cached:
            self.stats["cache_hits"] += 1
            return cached

        result = self._evaluate_single(solution, agent_profile)
        self.cache.put(cache_key, result)
        self.stats["llm_calls"] += 1

        if Config.SHOW_ANIMATIONS:
            time.sleep(0.1)

        return result

    def _evaluate_single(self, solution: str, agent_profile: str) -> Dict:
        """AvaliaÃ§Ã£o otimizada de uma Ãºnica soluÃ§Ã£o"""
        self.call_count += 1

        # Identifica perfil
        profile_key = None
        for key in self.patterns.keys():
            if key in agent_profile.lower():
                profile_key = key
                break

        if not profile_key:
            profile_key = "engenheiro"

        profile_data = self.patterns[profile_key]

        # Conta matches usando regex compilado
        positive_matches = len(profile_data["positive"].findall(solution))
        negative_matches = len(profile_data["negative"].findall(solution))

        # Score base
        base_score = np.random.uniform(0.4, 0.6)
        adjusted_score = np.clip(
            base_score + (positive_matches * 0.15) - (negative_matches * 0.1),
            0.1, 1.0
        )

        # Gera scores vetorizados
        metrics = ["fluÃªncia", "originalidade", "flexibilidade", "elaboraÃ§Ã£o", "adequaÃ§Ã£o", "impacto"]
        scores = {}

        boost_mask = np.array([m in profile_data["boost_metrics"] for m in metrics])
        base_scores = np.full(len(metrics), adjusted_score)
        noise = np.random.uniform(-0.1, 0.2, len(metrics))
        noise[~boost_mask] = np.random.uniform(-0.1, 0.1, (~boost_mask).sum())

        final_scores = np.clip(base_scores + noise, 0, 1)
        scores = dict(zip(metrics, final_scores))

        # Gera justificativa
        justification = self._generate_justification(solution, profile_key, scores)

        return {
            "scores": scores,
            "reasoning": justification,
            "confidence": np.random.uniform(0.7, 0.95),
            "profile_alignment": adjusted_score
        }

    def _generate_justification(self, solution: str, profile: str, scores: Dict) -> str:
        """Gera justificativa simulada"""
        justifications = {
            "engenheiro": "SoluÃ§Ã£o prÃ¡tica com foco em funcionalidade e eficiÃªncia tÃ©cnica",
            "artista": "Abordagem criativa valorizando expressÃ£o e originalidade estÃ©tica",
            "cientista": "MÃ©todo sistemÃ¡tico baseado em princÃ­pios cientÃ­ficos fundamentados"
        }
        return justifications.get(profile, "AnÃ¡lise baseada em critÃ©rios mÃºltiplos")

    def mediate_negotiation(self, agents: List, solutions: List, round_num: int) -> str:
        """Simula mediaÃ§Ã£o de LLM em negociaÃ§Ã£o"""
        self.call_count += 1
        self.stats["llm_calls"] += 1

        mediations = [
            "Os agentes identificaram pontos de convergÃªncia nas soluÃ§Ãµes prÃ¡ticas",
            "HÃ¡ consenso emergente sobre a importÃ¢ncia da viabilidade tÃ©cnica",
            "As perspectivas criativas estÃ£o sendo valorizadas pelo grupo",
            "O debate revelou critÃ©rios compartilhados nÃ£o percebidos inicialmente"
        ]

        return mediations[min(round_num, len(mediations)-1)]

# ========================= ESTRUTURAS DE DADOS OTIMIZADAS =========================

@dataclass
class Solution:
    """ğŸ’¡ SoluÃ§Ã£o otimizada com arrays NumPy internos"""
    id: int
    description: str
    scores: Dict[str, float] = field(default_factory=dict)
    scores_array: np.ndarray = field(default=None)
    llm_evaluations: Dict[str, Dict] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    consensus_history: List[int] = field(default_factory=list)

    def __post_init__(self):
        if self.scores and self.scores_array is None:
            self.scores_array = np.array(list(self.scores.values()))

    def __hash__(self):
        return hash(self.id)

    def get_combined_score(self, agent_id: str, use_llm: bool = False) -> float:
        """Combina scores algorÃ­tmicos com avaliaÃ§Ãµes LLM"""
        algo_score = np.mean(list(self.scores.values()))

        if use_llm and str(agent_id) in self.llm_evaluations:
            llm_score = self.llm_evaluations[str(agent_id)].get("profile_alignment", 0.5)
            # MÃ©dia ponderada: 70% LLM, 30% algoritmo
            return 0.7 * llm_score + 0.3 * algo_score

        return algo_score

@dataclass
class Agent:
    """ğŸ‘¤ Agente otimizado com arrays prÃ©-computados"""
    id: int
    name: str
    profile: str
    emoji: str
    metric_preferences: Dict[CreativityMetric, float]
    preferences_array: np.ndarray = field(default=None)
    personality_traits: Dict[str, float] = field(default_factory=dict)
    negotiation_history: List[Dict] = field(default_factory=list)
    satisfaction_curve: List[float] = field(default_factory=list)
    original_preferences: Dict[CreativityMetric, MetricPreference] = field(default_factory=dict)

    def __post_init__(self):
        # Vetoriza preferÃªncias
        if self.metric_preferences and self.preferences_array is None:
            self.preferences_array = np.array(list(self.metric_preferences.values()))

        # Adiciona traÃ§os de personalidade
        if not self.personality_traits:
            self.personality_traits = {
                "flexibility": np.random.uniform(0.3, 0.7),
                "assertiveness": np.random.uniform(0.4, 0.8),
                "openness": np.random.uniform(0.5, 0.9)
            }

    def visualize_preferences(self) -> None:
        """Visualiza preferÃªncias do agente com grÃ¡ficos ricos"""
        if not VISUALIZATION_AVAILABLE:
            return

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

        # GrÃ¡fico de barras das preferÃªncias
        metrics = list(self.original_preferences.keys())
        values = list(self.original_preferences.values())
        colors = [v.color for v in values]

        bars = ax1.bar(range(len(metrics)), [v.value for v in values], color=colors)
        ax1.set_xticks(range(len(metrics)))
        ax1.set_xticklabels([m.icon + " " + m.value for m in metrics], rotation=45, ha='right')
        ax1.set_ylim(0, 1)
        ax1.set_title(f"{self.emoji} {self.name} - PreferÃªncias de Criatividade")
        ax1.set_ylabel("Peso da PreferÃªncia")
        ax1.grid(axis='y', alpha=0.3)

        # Adiciona valores nas barras
        for bar, value in zip(bars, values):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height,
                    f'{value.visual}\n{value.value:.1f}',
                    ha='center', va='bottom', fontsize=9)

        # Radar chart dos traÃ§os de personalidade
        traits = list(self.personality_traits.keys())
        trait_values = list(self.personality_traits.values())

        angles = np.linspace(0, 2 * np.pi, len(traits), endpoint=False).tolist()
        trait_values = trait_values + [trait_values[0]]
        angles += angles[:1]

        ax2 = plt.subplot(122, projection='polar')
        ax2.plot(angles, trait_values, 'o-', linewidth=2, color='#FF6B6B')
        ax2.fill(angles, trait_values, alpha=0.25, color='#FF6B6B')
        ax2.set_xticks(angles[:-1])
        ax2.set_xticklabels(traits)
        ax2.set_ylim(0, 1)
        ax2.set_title(f"TraÃ§os de Personalidade")
        ax2.grid(True)

        plt.tight_layout()
        plt.show()

# ========================= VISUALIZADOR INTERATIVO COMPLETO =========================

class InteractiveVisualizer:
    """ğŸ“Š Sistema de visualizaÃ§Ã£o rica e interativa"""

    @staticmethod
    def show_consensus_evolution(history: List[Dict]) -> None:
        """Mostra evoluÃ§Ã£o do consenso ao longo das rodadas"""
        if not history or not VISUALIZATION_AVAILABLE:
            return

        rounds = [h['round'] for h in history]
        avg_satisfaction = [np.mean(h['satisfactions']) for h in history]
        min_satisfaction = [np.min(h['satisfactions']) for h in history]
        max_satisfaction = [np.max(h['satisfactions']) for h in history]

        # Cria figura interativa com Plotly
        fig = go.Figure()

        # Adiciona linha de satisfaÃ§Ã£o mÃ©dia
        fig.add_trace(go.Scatter(
            x=rounds,
            y=avg_satisfaction,
            mode='lines+markers',
            name='SatisfaÃ§Ã£o MÃ©dia',
            line=dict(color='#4CAF50', width=3),
            marker=dict(size=10)
        ))

        # Adiciona Ã¡rea de min-max
        fig.add_trace(go.Scatter(
            x=rounds + rounds[::-1],
            y=max_satisfaction + min_satisfaction[::-1],
            fill='toself',
            fillcolor='rgba(76, 175, 80, 0.2)',
            line=dict(color='rgba(255,255,255,0)'),
            showlegend=False,
            hoverinfo='skip'
        ))

        # Adiciona linhas de min e max
        fig.add_trace(go.Scatter(
            x=rounds,
            y=min_satisfaction,
            mode='lines',
            name='MÃ­nimo',
            line=dict(color='#FF6B6B', width=1, dash='dash')
        ))

        fig.add_trace(go.Scatter(
            x=rounds,
            y=max_satisfaction,
            mode='lines',
            name='MÃ¡ximo',
            line=dict(color='#4ECDC4', width=1, dash='dash')
        ))

        fig.update_layout(
            title="ğŸ“ˆ EvoluÃ§Ã£o da SatisfaÃ§Ã£o do Consenso",
            xaxis_title="Rodada de NegociaÃ§Ã£o",
            yaxis_title="SatisfaÃ§Ã£o",
            yaxis=dict(range=[0, 1]),
            hovermode='x unified',
            template='plotly_dark',
            height=400
        )

        fig.show()

    @staticmethod
    def show_solution_comparison(solutions: List[Solution], agents: List[Agent]) -> None:
        """Cria heatmap interativo comparando avaliaÃ§Ãµes"""
        if not VISUALIZATION_AVAILABLE:
            return

        # Prepara dados para heatmap
        data = []
        for agent in agents:
            row = []
            for solution in solutions:
                score = solution.get_combined_score(str(agent.id), Config.USE_LLM)
                row.append(score)
            data.append(row)

        # Cria heatmap com Plotly
        fig = go.Figure(data=go.Heatmap(
            z=data,
            x=[f"Sol {s.id+1}" for s in solutions],
            y=[f"{a.emoji} {a.name}" for a in agents],
            colorscale='RdYlGn',
            text=[[f"{val:.2f}" for val in row] for row in data],
            texttemplate="%{text}",
            textfont={"size": 10},
            colorbar=dict(title="Score"),
            hoverongaps=False
        ))

        # Adiciona anotaÃ§Ãµes para as top soluÃ§Ãµes
        for i, solution in enumerate(solutions[:3]):
            fig.add_annotation(
                x=i, y=-0.5,
                text=f"â­",
                showarrow=False,
                font=dict(size=20)
            )

        fig.update_layout(
            title="ğŸ¯ Matriz de AvaliaÃ§Ã£o: Agentes vs SoluÃ§Ãµes",
            xaxis_title="SoluÃ§Ãµes",
            yaxis_title="Agentes",
            template='plotly_white',
            height=400
        )

        fig.show()

    @staticmethod
    def show_negotiation_dynamics(agents: List[Agent]) -> None:
        """Visualiza dinÃ¢mica de negociaÃ§Ã£o entre agentes"""
        if not VISUALIZATION_AVAILABLE or not agents or not agents[0].satisfaction_curve:
            return

        fig = go.Figure()

        colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8']

        for i, agent in enumerate(agents):
            if agent.satisfaction_curve:
                fig.add_trace(go.Scatter(
                    x=list(range(len(agent.satisfaction_curve))),
                    y=agent.satisfaction_curve,
                    mode='lines+markers',
                    name=f"{agent.emoji} {agent.name}",
                    line=dict(color=colors[i % len(colors)], width=2),
                    marker=dict(size=8),
                    hovertemplate='%{y:.2%}<extra></extra>'
                ))

        # Adiciona linha de referÃªncia em 50%
        fig.add_hline(y=0.5, line_dash="dash", line_color="gray", opacity=0.5)

        fig.update_layout(
            title="ğŸ”„ DinÃ¢mica de SatisfaÃ§Ã£o Durante NegociaÃ§Ã£o",
            xaxis_title="IteraÃ§Ã£o",
            yaxis_title="NÃ­vel de SatisfaÃ§Ã£o",
            yaxis=dict(range=[0, 1], tickformat='.0%'),
            hovermode='x unified',
            template='plotly_dark',
            showlegend=True,
            height=400
        )

        fig.show()

    @staticmethod
    def show_final_consensus_breakdown(solutions: List[Solution],
                                      consensus: List[int],
                                      agents: List[Agent]) -> None:
        """VisualizaÃ§Ã£o detalhada do consenso final"""
        if not VISUALIZATION_AVAILABLE:
            return

        # Prepara dados para o grÃ¡fico de barras empilhadas
        metrics = [m.value for m in CreativityMetric]

        fig = go.Figure()

        for i, sol_idx in enumerate(consensus[:5]):  # Top 5 soluÃ§Ãµes
            solution = solutions[sol_idx]
            scores = [solution.scores.get(metric, 0) for metric in metrics]

            fig.add_trace(go.Bar(
                name=f"#{i+1} Sol {sol_idx+1}",
                x=metrics,
                y=scores,
                text=[f"{s:.2f}" for s in scores],
                textposition='auto',
            ))

        fig.update_layout(
            title="ğŸ“Š Breakdown das Top 5 SoluÃ§Ãµes por MÃ©trica",
            xaxis_title="MÃ©tricas de Criatividade",
            yaxis_title="Score",
            barmode='group',
            template='plotly_white',
            height=400
        )

        fig.show()

# ========================= FRAMEWORK HÃBRIDO COMPLETO =========================

class CompleteHybridFramework:
    """ğŸš€ Framework HÃ­brido Completo com Performance e VisualizaÃ§Ãµes"""

    def __init__(self, use_llm: bool = None):
        self.use_llm = use_llm if use_llm is not None else Config.USE_LLM
        self.solutions: List[Solution] = []
        self.agents: List[Agent] = []
        self.consensus_history: List[Dict] = []
        self.llm_simulator = OptimizedLLMSimulator()
        self.visualizer = InteractiveVisualizer()

        # Cache e prÃ©-computaÃ§Ã£o
        self.cache = OptimizedCache(Config.CACHE_SIZE)
        self._precomputed = {}
        self._patterns = None

        # EstatÃ­sticas
        self.stats = {
            "llm_calls": 0,
            "cache_hits": 0,
            "total_time": 0,
            "rounds_completed": 0,
            "vectorized_ops": 0,
            "parallel_ops": 0
        }

        # Sincroniza estatÃ­sticas com simulador
        self.llm_simulator.stats = self.stats

        print("â•”" + "â•" * 78 + "â•—")
        print("â•‘" + " " * 15 + "ğŸš€ FRAMEWORK HÃBRIDO v5.0 INICIALIZADO ğŸš€" + " " * 18 + "â•‘")
        print("â•‘" + " " * 78 + "â•‘")
        print(f"â•‘  Modo: {'ğŸ§  LLM Habilitado' if self.use_llm else 'âš¡ Algoritmo Puro':<40} " + " " * 26 + "â•‘")
        print(f"â•‘  Cache: {'âœ… Ativado' if Config.CACHE_LLM_RESPONSES else 'âŒ Desativado':<40} " + " " * 25 + "â•‘")
        print(f"â•‘  ParalelizaÃ§Ã£o: {'âœ… ' + str(Config.MAX_WORKERS) + ' workers' if Config.USE_PARALLEL else 'âŒ Desativada':<40} " + " " * 19 + "â•‘")
        print(f"â•‘  VetorizaÃ§Ã£o: {'âœ… NumPy' if Config.USE_VECTORIZATION else 'âŒ Desativada':<40} " + " " * 19 + "â•‘")
        print(f"â•‘  Numba JIT: {'âœ… DisponÃ­vel' if NUMBA_AVAILABLE else 'âŒ NÃ£o disponÃ­vel':<40} " + " " * 20 + "â•‘")
        print(f"â•‘  VisualizaÃ§Ã£o: {'ğŸ“Š Interativa' if Config.PLOT_STYLE == 'interactive' else 'ğŸ“ˆ EstÃ¡tica':<40} " + " " * 17 + "â•‘")
        print("â•š" + "â•" * 78 + "â•\n")

    def add_solution(self, description: str) -> None:
        """Adiciona soluÃ§Ã£o com anÃ¡lise hÃ­brida e visualizaÃ§Ã£o"""
        solution_id = len(self.solutions)
        solution = Solution(id=solution_id, description=description)

        # AnÃ¡lise algorÃ­tmica
        solution.scores = self._analyze_solution_algorithmic(description)
        solution.scores_array = np.array(list(solution.scores.values()))

        # Metadados
        solution.metadata = {
            "word_count": len(description.split()),
            "complexity": self._calculate_complexity(description),
            "timestamp": datetime.now().isoformat()
        }

        self.solutions.append(solution)

        # VisualizaÃ§Ã£o detalhada
        print(f"{'â”€' * 80}")
        print(f"âœ… SoluÃ§Ã£o {solution_id + 1} adicionada")
        print(f"ğŸ“ '{description[:60]}...'")
        print(f"ğŸ“Š Complexidade: {'â–ˆ' * int(solution.metadata['complexity'] * 10)}")
        print(f"ğŸ“ˆ Scores:")
        for metric, score in solution.scores.items():
            bar = 'â–ˆ' * int(score * 10) + 'â–‘' * (10 - int(score * 10))
            print(f"   {metric:<15} {bar} {score:.2f}")

    def add_solutions_batch(self, descriptions: List[str]) -> None:
        """Adiciona mÃºltiplas soluÃ§Ãµes em batch com paralelizaÃ§Ã£o"""
        start_time = time.time()

        print(f"\n{'â•' * 80}")
        print(f"ğŸ“ ADICIONANDO {len(descriptions)} SOLUÃ‡Ã•ES")
        print(f"{'â•' * 80}\n")

        if Config.USE_PARALLEL:
            # Cria pool local com context manager
            with Pool(processes=Config.MAX_WORKERS) as pool:
                scores_list = pool.map(self._analyze_solution_algorithmic, descriptions)
            self.stats["parallel_ops"] += 1
        else:
            scores_list = [self._analyze_solution_algorithmic(desc) for desc in descriptions]

        # Cria soluÃ§Ãµes
        for i, (desc, scores) in enumerate(zip(descriptions, scores_list)):
            solution = Solution(
                id=len(self.solutions),
                description=desc,
                scores=scores,
                scores_array=np.array(list(scores.values()))
            )

            solution.metadata = {
                "word_count": len(desc.split()),
                "complexity": self._calculate_complexity(desc),
                "timestamp": datetime.now().isoformat()
            }

            self.solutions.append(solution)

            # AnimaÃ§Ã£o de progresso
            if Config.SHOW_ANIMATIONS:
                print(f"  [{i+1}/{len(descriptions)}] {desc[:50]}...")
                time.sleep(0.1)

        elapsed = time.time() - start_time
        print(f"\nâš¡ {len(descriptions)} soluÃ§Ãµes processadas em {elapsed:.3f}s")
        print(f"   Velocidade: {len(descriptions)/elapsed:.1f} soluÃ§Ãµes/s")

    def _compile_patterns(self) -> Dict:
        """Compila padrÃµes regex uma Ãºnica vez"""
        if self._patterns is None:
            keyword_weights = {
                "fluÃªncia": ["usar", "criar", "fazer", "aplicar", "desenvolver"],
                "originalidade": ["improvisada", "arte", "mÃ³bile", "Ãºnico", "novo"],
                "flexibilidade": ["vÃ¡rias", "diferentes", "alternativo", "versÃ¡til"],
                "elaboraÃ§Ã£o": ["precisos", "calibrar", "detalhado", "complexo"],
                "adequaÃ§Ã£o": ["simples", "prÃ¡tico", "Ãºtil", "eficiente", "fÃ¡cil"],
                "impacto": ["resolver", "transformar", "melhorar", "revolucionar"]
            }

            self._patterns = {}
            for metric, words in keyword_weights.items():
                self._patterns[metric] = re.compile('|'.join(words), re.IGNORECASE)

        return self._patterns

    def _analyze_solution_algorithmic(self, description: str) -> Dict[str, float]:
        """AnÃ¡lise otimizada com regex prÃ©-compilado"""
        patterns = self._compile_patterns()
        scores = {}

        base_scores = {
            "fluÃªncia": 0.5, "originalidade": 0.4, "flexibilidade": 0.45,
            "elaboraÃ§Ã£o": 0.5, "adequaÃ§Ã£o": 0.55, "impacto": 0.4
        }

        boosts = {
            "fluÃªncia": 0.1, "originalidade": 0.15, "flexibilidade": 0.12,
            "elaboraÃ§Ã£o": 0.1, "adequaÃ§Ã£o": 0.08, "impacto": 0.13
        }

        for metric, pattern in patterns.items():
            matches = len(pattern.findall(description))
            score = base_scores[metric] + (matches * boosts[metric])
            scores[metric] = min(1.0, score + np.random.uniform(-0.05, 0.05))

        return scores

    def _calculate_complexity(self, description: str) -> float:
        """Calcula complexidade usando vetorizaÃ§Ã£o"""
        technical_terms = ["circuito", "calibrar", "precisos", "elÃ©trico"]
        action_verbs = ["usar", "criar", "fazer", "estabilizar"]

        desc_lower = description.lower()
        factors = np.array([
            len(description) / 200,
            sum(1 for term in technical_terms if term in desc_lower) / 4,
            sum(1 for verb in action_verbs if verb in desc_lower) / 4
        ])

        return np.clip(factors.mean(), 0, 1)

    def add_agent(self, name: str, profile: str, emoji: str,
                  preferences: Dict[CreativityMetric, MetricPreference]) -> None:
        """Adiciona agente com visualizaÃ§Ã£o completa"""
        agent_id = len(self.agents)

        numeric_preferences = {
            metric: pref.value for metric, pref in preferences.items()
        }

        preferences_array = np.array(list(numeric_preferences.values()))

        agent = Agent(
            id=agent_id,
            name=name,
            profile=profile,
            emoji=emoji,
            metric_preferences=numeric_preferences,
            preferences_array=preferences_array,
            original_preferences=preferences
        )

        self.agents.append(agent)

        # Invalidar cache de matrizes
        self._precomputed.clear()

        # VisualizaÃ§Ã£o rica do agente
        print(f"\n{'â•' * 80}")
        print(f"{emoji} AGENTE ADICIONADO: {name}")
        print(f"ğŸ“‹ Perfil: {profile}")
        print(f"ğŸ¯ PreferÃªncias:")

        for metric, pref in preferences.items():
            bar = pref.visual + 'â–‘' * (5 - len(pref.visual)//2)
            print(f"   {metric.icon} {metric.value:<15} {bar} ({pref.value:.1f}) - {metric.description}")

        print(f"\nğŸ§  TraÃ§os de Personalidade:")
        for trait, value in agent.personality_traits.items():
            bar = 'â–ˆ' * int(value * 10) + 'â–‘' * (10 - int(value * 10))
            print(f"   {trait:<15} {bar} {value:.2f}")

        # Se LLM ativado, prÃ©-calcula avaliaÃ§Ãµes
        if self.use_llm and self.solutions:
            print(f"\nğŸ§  Processando avaliaÃ§Ãµes com LLM...")
            self._precompute_llm_evaluations(agent)

        # VisualizaÃ§Ã£o grÃ¡fica do agente
        if Config.SHOW_ANIMATIONS:
            agent.visualize_preferences()

    def _precompute_llm_evaluations(self, agent: Agent) -> None:
        """PrÃ©-calcula avaliaÃ§Ãµes LLM"""
        for solution in self.solutions:
            if str(agent.id) not in solution.llm_evaluations:
                evaluation = self.llm_simulator.evaluate_solution(
                    solution.description,
                    agent.profile
                )
                solution.llm_evaluations[str(agent.id)] = evaluation

    def _get_initial_rankings_vectorized(self) -> np.ndarray:
        """Rankings iniciais usando operaÃ§Ãµes matriciais vetorizadas"""
        n_agents = len(self.agents)
        n_solutions = len(self.solutions)

        pref_matrix = np.array([agent.preferences_array for agent in self.agents])
        sol_matrix = np.array([sol.scores_array for sol in self.solutions])

        score_matrix = pref_matrix @ sol_matrix.T

        pref_sums = pref_matrix.sum(axis=1, keepdims=True)
        pref_sums[pref_sums == 0] = 1
        score_matrix = score_matrix / pref_sums

        rankings = np.argsort(-score_matrix, axis=1)

        self.stats["vectorized_ops"] += 1

        return rankings

    def run_hybrid_consensus(self, method: ConsensusMethod = ConsensusMethod.HYBRID,
                           rounds: int = 3) -> List[int]:
        """Executa consenso hÃ­brido com visualizaÃ§Ãµes completas"""
        start_time = time.time()

        print(f"\n{'â•”' + 'â•' * 78 + 'â•—'}")
        print(f"â•‘{' ' * 15}ğŸš€ INICIANDO CONSENSO HÃBRIDO ğŸš€{' ' * 28}â•‘")
        print(f"â•‘{' ' * 78}â•‘")
        print(f"â•‘  MÃ©todo: {method._value_[2]:<40} {method._value_[1]}{' ' * 24}â•‘")
        print(f"â•‘  Rodadas: {rounds:<40}{' ' * 27}â•‘")
        print(f"â•‘  Agentes: {len(self.agents):<40}{' ' * 27}â•‘")
        print(f"â•‘  SoluÃ§Ãµes: {len(self.solutions):<40}{' ' * 26}â•‘")
        print(f"â•š{'â•' * 78}â•\n")

        # VisualizaÃ§Ã£o inicial
        if Config.SHOW_ANIMATIONS:
            print("ğŸ“Š Gerando visualizaÃ§Ãµes iniciais...")
            self.visualizer.show_solution_comparison(self.solutions, self.agents)

        # Rankings iniciais
        agent_rankings = self._get_initial_rankings()

        # Processo de negociaÃ§Ã£o
        for round_num in range(rounds):
            print(f"\n{'â”' * 80}")
            print(f"ğŸ”„ RODADA {round_num + 1}/{rounds}")
            print(f"{'â”' * 80}\n")

            # Consenso da rodada
            if method == ConsensusMethod.HYBRID:
                consensus = self._hybrid_consensus_round(agent_rankings, round_num)
            elif method == ConsensusMethod.LLM_MEDIATED and self.use_llm:
                consensus = self._llm_mediated_consensus(agent_rankings, round_num)
            else:
                consensus = self._algorithmic_consensus(agent_rankings, method)

            # Calcula satisfaÃ§Ãµes
            satisfactions = self._calculate_satisfactions(consensus, agent_rankings)

            # Atualiza histÃ³rico
            for i, agent in enumerate(self.agents):
                agent.satisfaction_curve.append(satisfactions[i])

            # VisualizaÃ§Ã£o da rodada
            self._display_round_results(round_num + 1, consensus, satisfactions)

            # NegociaÃ§Ã£o adaptativa
            if round_num < rounds - 1:
                agent_rankings = self._adaptive_negotiation(
                    agent_rankings, consensus, satisfactions, round_num
                )

            # Salva histÃ³rico
            self.consensus_history.append({
                'round': round_num + 1,
                'consensus': consensus.copy(),
                'satisfactions': satisfactions.copy(),
                'method': method._value_[0]
            })

            self.stats["rounds_completed"] += 1

        # EstatÃ­sticas finais
        self.stats["total_time"] = time.time() - start_time

        # VisualizaÃ§Ãµes finais
        self._show_final_results(consensus)

        return consensus

    def _get_initial_rankings(self) -> List[List[int]]:
        """ObtÃ©m rankings iniciais com visualizaÃ§Ã£o detalhada"""
        print("ğŸ“Š Calculando rankings iniciais dos agentes...\n")

        if Config.USE_VECTORIZATION:
            rankings_np = self._get_initial_rankings_vectorized()
            agent_rankings = rankings_np.tolist()
        else:
            agent_rankings = []
            for agent in self.agents:
                scores = []
                for solution in self.solutions:
                    if self.use_llm and str(agent.id) in solution.llm_evaluations:
                        score = solution.get_combined_score(str(agent.id), True)
                    else:
                        weights = agent.preferences_array
                        solution_scores = np.array([
                            solution.scores.get(m.value, 0.5)
                            for m in CreativityMetric
                        ])
                        score = np.dot(weights, solution_scores) / (weights.sum() if weights.sum() != 0 else 1)
                    scores.append(score)

                ranking = np.argsort(scores)[::-1].tolist()
                agent_rankings.append(ranking)

        # Exibe rankings
        for agent, ranking in zip(self.agents, agent_rankings):
            print(f"{agent.emoji} {agent.name}:")
            medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
            for pos, sol_idx in enumerate(ranking[:3]):
                medal = medals[pos] if pos < 3 else f"{pos+1}Âº"
                print(f"  {medal} SoluÃ§Ã£o {sol_idx+1}: {self.solutions[sol_idx].description[:40]}...")
            if len(ranking) > 3:
                print(f"  ... e {len(ranking) - 3} outras soluÃ§Ãµes")
            print()

        return agent_rankings

    def _hybrid_consensus_round(self, rankings: List[List[int]], round_num: int) -> List[int]:
        """Rodada de consenso hÃ­brido com decisÃ£o inteligente"""
        n_solutions = len(self.solutions)

        divergence = self._calculate_divergence(rankings)

        print(f"ğŸ“Š AnÃ¡lise de DivergÃªncia: {divergence:.2%}")

        if divergence > 0.7:
            print("   ğŸ”´ DivergÃªncia ALTA - conflito significativo")
        elif divergence > 0.4:
            print("   ğŸŸ¡ DivergÃªncia MÃ‰DIA - diferenÃ§as moderadas")
        else:
            print("   ğŸŸ¢ DivergÃªncia BAIXA - boa convergÃªncia")

        if divergence > 0.6 and self.use_llm and self.stats.get("llm_calls", 0) < Config.MAX_LLM_CALLS:
            print("ğŸ§  Usando mediaÃ§Ã£o LLM para alta divergÃªncia")
            mediation = self.llm_simulator.mediate_negotiation(
                self.agents, self.solutions, round_num
            )
            print(f"ğŸ’¬ Insight LLM: {mediation}")
            return self._nash_bargaining_sa(rankings, n_solutions)
        else:
            print("âš¡ Usando consenso algorÃ­tmico eficiente")
            return self._borda_count_vectorized(rankings, n_solutions)

    def _llm_mediated_consensus(self, rankings: List[List[int]], round_num: int) -> List[int]:
        """Consenso mediado por LLM"""
        if not self.use_llm:
            return self._algorithmic_consensus(rankings, ConsensusMethod.NASH)

        print("ğŸ§  Iniciando mediaÃ§Ã£o por LLM...")
        mediation = self.llm_simulator.mediate_negotiation(
            self.agents, self.solutions, round_num
        )
        print(f"ğŸ’¬ MediaÃ§Ã£o: {mediation}")

        return self._nash_bargaining_sa(rankings, len(self.solutions))

    def _algorithmic_consensus(self, rankings: List[List[int]],
                             method: ConsensusMethod) -> List[int]:
        """Consenso algorÃ­tmico com mÃ©todos otimizados"""
        n = len(self.solutions)

        method_map = {
            ConsensusMethod.BORDA: self._borda_count_vectorized,
            ConsensusMethod.NASH: lambda r, n: self._nash_bargaining_sa(r, n),
            ConsensusMethod.CONDORCET: self._condorcet_winner,
            ConsensusMethod.SHAPLEY: self._shapley_value
        }

        func = method_map.get(method, self._borda_count_vectorized)
        return func(rankings, n)

    def _borda_count_vectorized(self, rankings: List[List[int]], n: int) -> List[int]:
        """Borda Count vetorizado"""
        scores = np.zeros(n)

        for ranking in rankings:
            for pos, sol_idx in enumerate(ranking):
                scores[sol_idx] += (n - pos - 1)

        self.stats["vectorized_ops"] += 1
        return np.argsort(scores)[::-1].tolist()

    def _nash_bargaining_sa(self, rankings: List[List[int]], n: int,
                           temperature: float = 1.0, cooling_rate: float = 0.95) -> List[int]:
        """Nash Bargaining com Simulated Annealing"""
        current = self._borda_count_vectorized(rankings, n)
        best = current.copy()
        best_product = self._calculate_nash_product(current, rankings)

        temp = temperature

        while temp > 0.01:
            i, j = np.random.choice(n, 2, replace=False)
            neighbor = current.copy()
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]

            neighbor_product = self._calculate_nash_product(neighbor, rankings)
            delta = neighbor_product - best_product

            if delta > 0 or np.random.random() < np.exp(delta / temp):
                current = neighbor
                if neighbor_product > best_product:
                    best = neighbor
                    best_product = neighbor_product

            temp *= cooling_rate

        return best

    def _condorcet_winner(self, rankings: List[List[int]], n: int) -> List[int]:
        """Encontra vencedor de Condorcet"""
        pairwise = np.zeros((n, n))

        for ranking in rankings:
            for i, sol_i in enumerate(ranking):
                for sol_j in ranking[i+1:]:
                    pairwise[sol_i, sol_j] += 1

        copeland = np.sum(pairwise > len(rankings)/2, axis=1) - \
                  np.sum(pairwise < len(rankings)/2, axis=1)

        return np.argsort(copeland)[::-1].tolist()

    def _shapley_value(self, rankings: List[List[int]], n: int) -> List[int]:
        """Calcula valores de Shapley"""
        values = np.zeros(n)

        for sol_idx in range(n):
            for ranking in rankings:
                if sol_idx in ranking:
                    pos = ranking.index(sol_idx)
                    values[sol_idx] += (n - pos) / n

        values /= len(rankings)
        return np.argsort(values)[::-1].tolist()

    def _calculate_nash_product(self, consensus: List[int],
                               agent_rankings: List[List[int]]) -> float:
        """Calcula produto de Nash"""
        satisfactions = self._calculate_satisfactions(consensus, agent_rankings)
        return np.prod(np.maximum(satisfactions, 0.01))

    def _kendall_tau_fast(self, r1: List[int], r2: List[int]) -> float:
        """Kendall tau otimizado"""
        if Config.USE_NUMBA and NUMBA_AVAILABLE:
            return kendall_tau_numba(np.array(r1), np.array(r2))

        n = len(r1)
        if n <= 1:
            return 1.0

        pos1 = {v: i for i, v in enumerate(r1)}
        pos2 = {v: i for i, v in enumerate(r2)}

        concordant = 0
        for i in range(n):
            for j in range(i+1, n):
                if r1[i] in pos2 and r1[j] in pos2 and pos2[r1[i]] < pos2[r1[j]]:
                    concordant += 1

        total = n * (n - 1) / 2
        return (2 * concordant / total - 1) if total > 0 else 1.0

    def _calculate_divergence(self, rankings: List[List[int]]) -> float:
        """Calcula divergÃªncia entre rankings"""
        if len(rankings) < 2:
            return 0.0

        correlations = []
        for i in range(len(rankings)):
            for j in range(i+1, len(rankings)):
                tau = self._kendall_tau_fast(rankings[i], rankings[j])
                correlations.append((tau + 1) / 2)

        return 1 - np.mean(correlations)

    def _calculate_satisfactions(self, consensus: List[int],
                                rankings: List[List[int]]) -> List[float]:
        """Calcula satisfaÃ§Ã£o de cada agente"""
        satisfactions = []

        for ranking in rankings:
            tau = self._kendall_tau_fast(consensus, ranking)
            satisfaction = (tau + 1) / 2
            satisfactions.append(satisfaction)

        return satisfactions

    def _adaptive_negotiation(self, current_rankings: List[List[int]],
                            consensus: List[int], satisfactions: List[float],
                            round_num: int) -> List[List[int]]:
        """NegociaÃ§Ã£o adaptativa com personalidade"""
        print("\nğŸ’¬ Fase de NegociaÃ§Ã£o Adaptativa")
        print("â”€" * 40)

        new_rankings = []

        for i, (agent, ranking, satisfaction) in enumerate(
            zip(self.agents, current_rankings, satisfactions)
        ):
            flexibility = agent.personality_traits["flexibility"]

            if satisfaction < 0.4:
                adjustment = 0.3 * flexibility
                status = "ğŸ”´ Ajuste forte"
            elif satisfaction < 0.6:
                adjustment = 0.15 * flexibility
                status = "ğŸŸ¡ Ajuste moderado"
            else:
                adjustment = 0.05 * flexibility
                status = "ğŸŸ¢ Ajuste mÃ­nimo"

            print(f"  {agent.emoji} {agent.name:<12} {status} ({adjustment:.1%})")

            new_ranking = self._adjust_ranking_smart(ranking, consensus, adjustment)
            new_rankings.append(new_ranking)

        return new_rankings

    def _adjust_ranking_smart(self, agent_ranking: List[int],
                             consensus: List[int], factor: float) -> List[int]:
        """Ajuste inteligente de ranking"""
        n = len(agent_ranking)

        agent_scores = np.array([n - i for i in range(n)])
        consensus_scores = np.zeros(n)

        for i, sol_idx in enumerate(consensus):
            if sol_idx in agent_ranking:
                idx = agent_ranking.index(sol_idx)
                consensus_scores[idx] = n - i

        hybrid = (1 - factor) * agent_scores + factor * consensus_scores
        hybrid += np.random.uniform(-0.01, 0.01, n)

        sorted_indices = np.argsort(hybrid)[::-1]
        return [agent_ranking[i] for i in sorted_indices]

    def _display_round_results(self, round_num: int, consensus: List[int],
                              satisfactions: List[float]) -> None:
        """Exibe resultados detalhados da rodada"""
        print(f"\nğŸ“Š RESULTADOS DA RODADA {round_num}")
        print("â”€" * 60)

        # Top 3 do consenso
        print("\nğŸ† Consenso Parcial:")
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
        for pos, sol_idx in enumerate(consensus[:3]):
            medal = medals[pos] if pos < 3 else f"{pos+1}Âº"
            solution = self.solutions[sol_idx]
            score_avg = np.mean(list(solution.scores.values()))
            print(f"  {medal} SoluÃ§Ã£o {sol_idx+1} (Score: {score_avg:.2f})")
            print(f"     â””â”€ {solution.description[:50]}...")

        # SatisfaÃ§Ã£o dos agentes
        print("\nğŸ˜Š NÃ­veis de SatisfaÃ§Ã£o:")
        for agent, sat in zip(self.agents, satisfactions):
            bar_length = int(sat * 20)
            bar = "â–ˆ" * bar_length + "â–‘" * (20 - bar_length)
            color = "ğŸŸ¢" if sat > 0.7 else "ğŸŸ¡" if sat > 0.4 else "ğŸ”´"
            print(f"  {agent.emoji} {agent.name:<12} {bar} {sat:.1%} {color}")

        # EstatÃ­sticas
        avg_sat = np.mean(satisfactions)
        std_sat = np.std(satisfactions)
        min_sat = np.min(satisfactions)
        max_sat = np.max(satisfactions)

        print(f"\nğŸ“ˆ EstatÃ­sticas:")
        print(f"  MÃ©dia: {avg_sat:.1%} | Desvio: {std_sat:.1%}")
        print(f"  MÃ­n: {min_sat:.1%} | MÃ¡x: {max_sat:.1%}")

    def _show_final_results(self, final_consensus: List[int]) -> None:
        """Exibe resultados finais com visualizaÃ§Ãµes completas"""
        print(f"\n{'â•' * 80}")
        print(f"{'ğŸŠ CONSENSO FINAL ALCANÃ‡ADO ğŸŠ':^80}")
        print(f"{'â•' * 80}\n")

        # Ranking final completo
        print("ğŸ RANKING FINAL CONSENSUADO:\n")

        for pos, sol_idx in enumerate(final_consensus):
            solution = self.solutions[sol_idx]

            # Visual diferenciado por posiÃ§Ã£o
            if pos == 0:
                icon = "ğŸ¥‡"
                box = "â–ˆ" * 80
                print(f"\n{box}")
            elif pos == 1:
                icon = "ğŸ¥ˆ"
                box = "â–“" * 80
                print(f"\n{box}")
            elif pos == 2:
                icon = "ğŸ¥‰"
                box = "â–’" * 80
                print(f"\n{box}")
            else:
                icon = f"{pos+1}Âº"
                box = "â–‘" * 80
                print(f"\n{box}")

            print(f"{icon} POSIÃ‡ÃƒO {pos + 1}")
            print(f"ğŸ“ {solution.description}")

            # Detalhamento de scores
            print(f"\nğŸ“Š AnÃ¡lise Detalhada:")
            for metric in CreativityMetric:
                score = solution.scores.get(metric.value, 0)
                bar = 'â–ˆ' * int(score * 10) + 'â–‘' * (10 - int(score * 10))
                print(f"   {metric.icon} {metric.value:<15} {bar} {score:.2f}")

            avg_score = np.mean(list(solution.scores.values()))
            print(f"\n   ğŸ“ˆ Score mÃ©dio: {avg_score:.2%}")

            if self.use_llm and solution.llm_evaluations:
                llm_scores = [e["profile_alignment"] for e in solution.llm_evaluations.values()]
                print(f"   ğŸ§  Alinhamento LLM: {np.mean(llm_scores):.2%}")

        # EstatÃ­sticas do processo
        print(f"\n{'â”€' * 80}")
        print("ğŸ“Š ESTATÃSTICAS DO PROCESSO:")
        print(f"  â±ï¸  Tempo total: {self.stats['total_time']:.2f}s")
        print(f"  ğŸ”„ Rodadas completadas: {self.stats['rounds_completed']}")
        print(f"  ğŸ“Š OperaÃ§Ãµes vetorizadas: {self.stats.get('vectorized_ops', 0)}")
        print(f"  ğŸš€ OperaÃ§Ãµes paralelas: {self.stats.get('parallel_ops', 0)}")

        if self.use_llm:
            print(f"  ğŸ§  Chamadas LLM: {self.stats.get('llm_calls', 0)}")
            print(f"  ğŸ’¾ Cache hits: {self.stats.get('cache_hits', 0)}")
            if self.cache.hit_rate > 0:
                print(f"  âš¡ Taxa de cache: {self.cache.hit_rate:.1%}")

        # Throughput
        if self.stats['total_time'] > 0:
            throughput = self.stats['rounds_completed'] / self.stats['total_time']
            print(f"  âš¡ Throughput: {throughput:.2f} rodadas/s")

        # VisualizaÃ§Ãµes finais interativas
        if Config.SHOW_ANIMATIONS and VISUALIZATION_AVAILABLE:
            print("\nğŸ“ˆ Gerando visualizaÃ§Ãµes finais interativas...")

            # EvoluÃ§Ã£o do consenso
            self.visualizer.show_consensus_evolution(self.consensus_history)

            # DinÃ¢mica de negociaÃ§Ã£o
            self.visualizer.show_negotiation_dynamics(self.agents)

            # ComparaÃ§Ã£o final
            self.visualizer.show_solution_comparison(self.solutions, self.agents)

            # Breakdown das top soluÃ§Ãµes
            self.visualizer.show_final_consensus_breakdown(
                self.solutions, final_consensus, self.agents
            )

    def generate_detailed_report(self) -> str:
        """Gera relatÃ³rio HTML detalhado e estilizado"""
        html = f"""
        <html>
        <head>
            <title>RelatÃ³rio - Framework HÃ­brido Multiagente v5.0</title>
            <style>
                body {{
                    font-family: 'Segoe UI', Arial, sans-serif;
                    margin: 40px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #333;
                }}
                .container {{
                    background: white;
                    border-radius: 15px;
                    padding: 30px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                }}
                h1 {{
                    color: #2c3e50;
                    text-align: center;
                    font-size: 2.5em;
                    margin-bottom: 30px;
                }}
                h2 {{
                    color: #34495e;
                    border-bottom: 3px solid #3498db;
                    padding-bottom: 10px;
                    margin-top: 30px;
                }}
                .stat-box {{
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 20px;
                    margin: 20px 0;
                    border-radius: 10px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
                }}
                .solution {{
                    background: #fff;
                    padding: 20px;
                    margin: 20px 0;
                    border-left: 5px solid #3498db;
                    border-radius: 5px;
                    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
                    transition: transform 0.3s;
                }}
                .solution:hover {{
                    transform: translateX(5px);
                }}
                .gold {{ border-left-color: #FFD700; background: #FFFACD; }}
                .silver {{ border-left-color: #C0C0C0; background: #F5F5F5; }}
                .bronze {{ border-left-color: #CD7F32; background: #FFF8DC; }}
                table {{
                    border-collapse: collapse;
                    width: 100%;
                    margin: 20px 0;
                }}
                th, td {{
                    border: 1px solid #ddd;
                    padding: 12px;
                    text-align: left;
                }}
                th {{
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    font-weight: bold;
                }}
                tr:nth-child(even) {{ background: #f9f9f9; }}
                tr:hover {{ background: #f5f5f5; }}
                .metric-bar {{
                    display: inline-block;
                    width: 100px;
                    height: 20px;
                    background: #e0e0e0;
                    border-radius: 10px;
                    overflow: hidden;
                    margin-left: 10px;
                }}
                .metric-fill {{
                    height: 100%;
                    background: linear-gradient(90deg, #4CAF50, #8BC34A);
                    border-radius: 10px;
                }}
                .agent-card {{
                    display: inline-block;
                    background: white;
                    border: 2px solid #3498db;
                    border-radius: 10px;
                    padding: 15px;
                    margin: 10px;
                    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
                }}
                .emoji {{ font-size: 2em; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>ğŸ“Š RelatÃ³rio do Framework HÃ­brido Multiagente v5.0</h1>

                <div class="stat-box">
                    <h2 style="color: white; border: none;">âš™ï¸ ConfiguraÃ§Ãµes da ExecuÃ§Ã£o</h2>
                    <p><strong>Modo:</strong> {Config.SIMULATION_MODE}</p>
                    <p><strong>LLM:</strong> {'âœ… Habilitado' if self.use_llm else 'âŒ Desabilitado'}</p>
                    <p><strong>Agentes:</strong> {len(self.agents)}</p>
                    <p><strong>SoluÃ§Ãµes:</strong> {len(self.solutions)}</p>
                    <p><strong>Rodadas:</strong> {self.stats['rounds_completed']}</p>
                    <p><strong>Tempo Total:</strong> {self.stats['total_time']:.2f}s</p>
                </div>

                <h2>ğŸ‘¥ Agentes Participantes</h2>
                <div style="text-align: center;">
        """

        for agent in self.agents:
            html += f"""
                <div class="agent-card">
                    <div class="emoji">{agent.emoji}</div>
                    <h4>{agent.name}</h4>
                    <p style="font-size: 0.9em; color: #666;">{agent.profile[:50]}...</p>
                </div>
            """

        html += """
                </div>

                <h2>ğŸ† Ranking Final Consensuado</h2>
        """

        if self.consensus_history:
            final = self.consensus_history[-1]['consensus']
            for pos, sol_idx in enumerate(final):
                sol = self.solutions[sol_idx]
                avg_score = np.mean(list(sol.scores.values()))

                medal_class = ""
                medal_icon = f"{pos+1}Âº"
                if pos == 0:
                    medal_class = "gold"
                    medal_icon = "ğŸ¥‡"
                elif pos == 1:
                    medal_class = "silver"
                    medal_icon = "ğŸ¥ˆ"
                elif pos == 2:
                    medal_class = "bronze"
                    medal_icon = "ğŸ¥‰"

                html += f"""
                <div class="solution {medal_class}">
                    <h3>{medal_icon} PosiÃ§Ã£o {pos+1}</h3>
                    <p><strong>DescriÃ§Ã£o:</strong> {sol.description}</p>
                    <p><strong>Score MÃ©dio:</strong> {avg_score:.2%}</p>
                    <div style="margin-top: 10px;">
                """

                for metric in CreativityMetric:
                    score = sol.scores.get(metric.value, 0)
                    html += f"""
                        <div style="margin: 5px 0;">
                            {metric.icon} {metric.value}:
                            <div class="metric-bar">
                                <div class="metric-fill" style="width: {score*100}%;"></div>
                            </div>
                            <span style="margin-left: 10px;">{score:.2f}</span>
                        </div>
                    """

                html += """
                    </div>
                </div>
                """

        html += f"""
                <h2>ğŸ“ˆ EstatÃ­sticas de Performance</h2>
                <table>
                    <tr><th>MÃ©trica</th><th>Valor</th></tr>
                    <tr><td>â±ï¸ Tempo Total</td><td>{self.stats['total_time']:.3f}s</td></tr>
                    <tr><td>ğŸ”„ Rodadas</td><td>{self.stats['rounds_completed']}</td></tr>
                    <tr><td>ğŸ“Š OperaÃ§Ãµes Vetorizadas</td><td>{self.stats.get('vectorized_ops', 0)}</td></tr>
                    <tr><td>ğŸš€ OperaÃ§Ãµes Paralelas</td><td>{self.stats.get('parallel_ops', 0)}</td></tr>
        """

        if self.use_llm:
            html += f"""
                    <tr><td>ğŸ§  Chamadas LLM</td><td>{self.stats.get('llm_calls', 0)}</td></tr>
                    <tr><td>ğŸ’¾ Cache Hits</td><td>{self.stats.get('cache_hits', 0)}</td></tr>
            """

        if self.stats['total_time'] > 0:
            throughput = self.stats['rounds_completed'] / self.stats['total_time']
            html += f"""
                    <tr><td>âš¡ Throughput</td><td>{throughput:.2f} rodadas/s</td></tr>
            """

        html += """
                </table>

                <h2>ğŸ“Š EvoluÃ§Ã£o da SatisfaÃ§Ã£o</h2>
                <p>A satisfaÃ§Ã£o mÃ©dia dos agentes evoluiu ao longo das rodadas:</p>
                <table>
                    <tr><th>Rodada</th><th>SatisfaÃ§Ã£o MÃ©dia</th><th>MÃ­nimo</th><th>MÃ¡ximo</th></tr>
        """

        for history in self.consensus_history:
            avg_sat = np.mean(history['satisfactions'])
            min_sat = np.min(history['satisfactions'])
            max_sat = np.max(history['satisfactions'])
            html += f"""
                    <tr>
                        <td>{history['round']}</td>
                        <td>{avg_sat:.1%}</td>
                        <td>{min_sat:.1%}</td>
                        <td>{max_sat:.1%}</td>
                    </tr>
            """

        html += f"""
                </table>

                <div style="text-align: center; margin-top: 40px; padding: 20px; background: #f0f0f0; border-radius: 10px;">
                    <p style="color: #666; font-size: 0.9em;">
                        RelatÃ³rio gerado em {datetime.now().strftime('%d/%m/%Y Ã s %H:%M:%S')}<br>
                        Framework HÃ­brido de DecisÃ£o Multiagente v5.0<br>
                        Performance Edition com VisualizaÃ§Ãµes Completas
                    </p>
                </div>
            </div>
        </body>
        </html>
        """

        return html

# ========================= FUNÃ‡ÃƒO PRINCIPAL =========================

def main():
    """ğŸš€ FunÃ§Ã£o principal com execuÃ§Ã£o completa e interativa"""

    # Banner inicial animado
    print("â•”" + "â•" * 78 + "â•—")
    print("â•‘" + " " * 8 + "ğŸ¯ FRAMEWORK HÃBRIDO DE DECISÃƒO MULTIAGENTE v5.0 ğŸ¯" + " " * 9 + "â•‘")
    print("â•‘" + " " * 78 + "â•‘")
    print("â•‘" + " " * 10 + "Performance Otimizada + VisualizaÃ§Ãµes Completas" + " " * 20 + "â•‘")
    print("â•š" + "â•" * 78 + "â•\n")

    # Escolha interativa do modo
    print("ğŸ¤” Escolha o modo de operaÃ§Ã£o:")
    print("  1. Algoritmo Puro (rÃ¡pido e gratuito)")
    print("  2. HÃ­brido com LLM Simulado (demonstraÃ§Ã£o completa)")

    choice = input("\nEscolha (1 ou 2): ").strip()
    use_llm = (choice == "2")

    if use_llm:
        print("\nâœ… Modo hÃ­brido ativado com LLM simulado")
        print("   (Em produÃ§Ã£o, substitua pelo OpenAI API real)")
    else:
        print("\nâš¡ Modo algorÃ­tmico puro ativado")

    # Inicializa framework
    framework = CompleteHybridFramework(use_llm=use_llm)

    # Adiciona as 6 soluÃ§Ãµes criativas
    print("\n" + "â•" * 80)
    print("ğŸ“ ADICIONANDO SOLUÃ‡Ã•ES CRIATIVAS")
    print("â•" * 80 + "\n")

    solutions = [
        "Usar uma moeda como chave de fenda improvisada para parafusos pequenos quando nÃ£o hÃ¡ ferramenta apropriada",
        "Criar arte colocando papel sobre moedas e fazendo decalques para capturar as texturas e desenhos",
        "Usar moedas como pesos precisos para calibrar uma balanÃ§a digital caseira",
        "Estabilizar uma mesa bamba colocando moedas sob a perna curta",
        "Criar um circuito elÃ©trico simples usando moedas como elementos condutores",
        "Amarrar vÃ¡rias moedas em um fio fino para criar um mÃ³bile que produz sons metÃ¡licos suaves"
    ]

    # Adiciona soluÃ§Ãµes em batch com animaÃ§Ã£o
    framework.add_solutions_batch(solutions)

    # Adiciona agentes com visualizaÃ§Ãµes
    print("\n" + "â•" * 80)
    print("ğŸ‘¥ CONFIGURANDO AGENTES INTELIGENTES")
    print("â•" * 80)

    # Agente 1: Engenheiro
    framework.add_agent(
        name="Engenheiro",
        profile="Especialista em soluÃ§Ãµes prÃ¡ticas e funcionais, valoriza eficiÃªncia tÃ©cnica",
        emoji="âš™ï¸",
        preferences={
            CreativityMetric.FLUENCIA: MetricPreference.MEDIA,
            CreativityMetric.ORIGINALIDADE: MetricPreference.BAIXA,
            CreativityMetric.FLEXIBILIDADE: MetricPreference.MEDIA,
            CreativityMetric.ELABORACAO: MetricPreference.ALTA,
            CreativityMetric.ADEQUACAO: MetricPreference.MUITO_ALTA,
            CreativityMetric.IMPACTO: MetricPreference.ALTA
        }
    )

    time.sleep(0.5)

    # Agente 2: Artista
    framework.add_agent(
        name="Artista",
        profile="Criativo focado em estÃ©tica e expressÃ£o, busca originalidade e beleza",
        emoji="ğŸ¨",
        preferences={
            CreativityMetric.FLUENCIA: MetricPreference.ALTA,
            CreativityMetric.ORIGINALIDADE: MetricPreference.MUITO_ALTA,
            CreativityMetric.FLEXIBILIDADE: MetricPreference.ALTA,
            CreativityMetric.ELABORACAO: MetricPreference.MEDIA,
            CreativityMetric.ADEQUACAO: MetricPreference.BAIXA,
            CreativityMetric.IMPACTO: MetricPreference.MEDIA
        }
    )

    time.sleep(0.5)

    # Agente 3: Cientista
    framework.add_agent(
        name="Cientista",
        profile="Pesquisador metÃ³dico, prioriza precisÃ£o e princÃ­pios cientÃ­ficos",
        emoji="ğŸ”¬",
        preferences={
            CreativityMetric.FLUENCIA: MetricPreference.MEDIA,
            CreativityMetric.ORIGINALIDADE: MetricPreference.MEDIA,
            CreativityMetric.FLEXIBILIDADE: MetricPreference.BAIXA,
            CreativityMetric.ELABORACAO: MetricPreference.MUITO_ALTA,
            CreativityMetric.ADEQUACAO: MetricPreference.ALTA,
            CreativityMetric.IMPACTO: MetricPreference.ALTA
        }
    )

    time.sleep(0.5)

    # Agente 4: Empreendedor
    framework.add_agent(
        name="Empreendedor",
        profile="VisionÃ¡rio de negÃ³cios, busca inovaÃ§Ã£o com viabilidade comercial",
        emoji="ğŸ’¼",
        preferences={
            CreativityMetric.FLUENCIA: MetricPreference.ALTA,
            CreativityMetric.ORIGINALIDADE: MetricPreference.ALTA,
            CreativityMetric.FLEXIBILIDADE: MetricPreference.MUITO_ALTA,
            CreativityMetric.ELABORACAO: MetricPreference.BAIXA,
            CreativityMetric.ADEQUACAO: MetricPreference.ALTA,
            CreativityMetric.IMPACTO: MetricPreference.MUITO_ALTA
        }
    )

    # Pausa dramÃ¡tica
    print("\n" + "â•" * 80)
    input("ğŸ¬ Pressione ENTER para iniciar o processo de consenso...")
    print("â•" * 80)

    # Executa consenso hÃ­brido
    method = ConsensusMethod.HYBRID if use_llm else ConsensusMethod.NASH

    final_consensus = framework.run_hybrid_consensus(
        method=method,
        rounds=3
    )

    # RelatÃ³rio opcional
    print("\n" + "â•" * 80)
    print("ğŸ“„ Deseja gerar relatÃ³rio HTML detalhado? (s/n)")

    if input().lower() == 's':
        report = framework.generate_detailed_report()

        # Salva relatÃ³rio
        filename = f"relatorio_multiagente_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report)

        print(f"âœ… RelatÃ³rio salvo como: {filename}")

        # Exibe preview do relatÃ³rio
        print("\nğŸ“Š Preview do relatÃ³rio:")
        display(HTML(report[:1000] + "..."))

    print("\n" + "â•" * 80)
    print("ğŸŠ SIMULAÃ‡ÃƒO CONCLUÃDA COM SUCESSO! ğŸŠ")
    print("â•" * 80)
    print("\nğŸ’¡ Dicas:")
    print("   â€¢ Para mÃ¡xima performance, instale Numba: pip install numba")
    print("   â€¢ Para usar LLM real, configure Config.OPENAI_API_KEY")
    print("   â€¢ VisualizaÃ§Ãµes interativas disponÃ­veis no Jupyter/Colab")

    return framework

# ========================= EXECUÃ‡ÃƒO =========================

if __name__ == "__main__":
    framework = main()